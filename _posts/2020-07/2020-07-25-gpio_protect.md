---
title : 라즈베리파이 GPIO 보호 방법
date : 2020-07-25 00:00:00 +09:00
categories : [DIY, GAME_MACHINE]
tags : [DIY기술관련]
---

게임기를 만들 때 스틱과 버튼의 입력 신호를 받을 때, 흔히 라즈베리파이의 GPIO를 이용하는 편이 많습니다.
보통은 GPIO를 Input (Pull-up) 모드 해 놓고, 버튼을 통해 GND와 결선을 해 놓습니다.
아주 간단하죠?

![](https://velog.velcdn.com/images/amos42/post/ba812277-997e-416e-8435-b5addedfc324/image.png)

그런데 이렇게 간단히 쓰다 보니... 간혹 간과하게 되는 것이 있습니다.
사실 GPIO는 어떠한 안전장치도 없이 CPU와 바로 직결 된 핀입니다.
사용자가 부담 없이 마음대로 쓰라고 제공되는 것이 아니란 것이죠.
때문에 약간만 실수를 해도 쉽게 손상을 입으며,
그 피해 정도는 단순히 GPIO 핀 하나에만 부담이 가해지는 수준이 아닌,
CPU 자체로 다이렉트로 데미지가 전달되어 CPU를 못 쓰게 되는 수준에까지 이를 수도 있습니다.

GPIO는 간단한 장치가 아닙니다. 플립플롭이라는 매우 섬세하고도 중요한 마이크로 회로로 이루어져 있습니다.
또한, 전원을 공급하는 것이 목적이 아닌, 단순히 신호를 위한 선이라고 생각하면 됩니다.
그런데 손쉽게 켜고 끌 수 있다는 간편함 때문에, 마치 특정 소자에 전원 공급용을 하거나 차단하는 용도로 쓰는 경우도 있는데, 극미량의 전류를 필요로 하는 소자가 아닌 한, 여기에 이런 형태로 전원을 공급하면 안 됩니다.

GPIO가 손상을 입는 이유는 간단합니다.
극히 섬세한 마이크로 회로이기 때문에 먼지만한 크기의 부품과 머리카락보다 더 얇은 선들로 연결되어 있는 회로인데... 여기에 과도한 전류가 흐르며 열이 가해지게 된다면 바로 회로가 타 버리는 것이죠.
즉, 허용 전압 이상이 걸려도 안 되지만, 그에 못지 않게 허용 전류 이상의 전류가 흐르지 않도록 해야 합니다.

보통 GPIO가 맛이 가는 경우는 다음과 같우가 많습니다.

> - INPUT 모드인 상태에서 VCC와 직결
> - OUTPUT 모드인 상태에서 GND와 직결
> - GPIO에 3.3V를 초과한 과전압이 흐를 때
> - 각 GPIO 핀의 허용 전류 이상이 흐를 때
> - 전체 GPIO로 흐르는 전류의 총합이 허용 전류 이상일 때

특히 자주 실수하는 것이 첫번째, 두번째의 케이스입니다.
즉, 다음과 같은 형태로 다이렉트로 결선되었을 때이죠.

![](https://velog.velcdn.com/images/amos42/post/97489f4b-7849-4d9d-87a5-0b31050aad42/image.png)

이렇게 결선이 되면 해당 GPIO는 아무런 브레이크 없이 최대의 전류가 흐르게 되기 때문에. 결국 GPIO가 과전류로 타버리게 됩니다.
운 좋으면 해당 GPIO 한개만 죽는 걸로 끝나지만, 운이 나쁘면 그 이상의 문제가 생기기도 합니다.

개인적으로 경험 해 본 GPIO 사망 증상들입니다.

* 해당 GPIO가 전혀 동작을 하지 않는다
* 바로 옆의 다른 GPIO와 연결 되어 있는 것처럼 인식한다.
* GPIO 핀이 부분이 금방 뜨거워진다.
* CPU 전체가 급격히 과열된다.
* 기타등등...

개인적인 경험이기에, 다른 경우엔 또 어떤 증상이 나타날지 모릅니다.
때문에 저런 회로 상태는 가급적 피해서 회로 및 장치 연결을 해야 합니다.
물론, 그 회로에 맞춰 GPIO의 모드 설정도 주의해야 합니다.

Retro-pie 순정 상태의 배포본을 그대로 설치한 다음 GPIO의 모드 설정 상태를 봤습니다.
다행이 모든 GPIO는 input 상태이군요.
이런 배포본으로 세팅 작업을 시작한다면, 특별히 뭔가 세팅을 하기 전 상태라 해도, 적어도 이 시점에선 GND와 쇼트되도록 만든 버튼들은 막 눌러도 딱히 문제가 없습니다.

![](https://velog.velcdn.com/images/amos42/post/6776d3ce-b06b-4cb2-bf2b-a6d7cd836fdb/image.png)

또다른 배포본입니다.
이 배포본의 경우엔 OLED 출력과 쿨링팬 제어 기능이 포함되어 있었습니다.
gpio 상태를 보니... 역시나 몇군데 OUTPUT 모드로 설정되어 있는 GPIO들이 있습니다.

![](https://velog.velcdn.com/images/amos42/post/1db169e5-77cc-4096-9395-f706331bdc73/image.png)

그 중에서 GPIO2번과 GPIO21번은 비록 OUTPUT 모드이긴 하지만 값은 0으로 되어 있어서 아직은 괜찮습니다만, GPIO3번은 OUTPUT이면서 값은 1이 되어 있습니다.
즉, GPIO3번 핀과 GND를 직결하면 바로 맛이 갈 수 있는 상태가 되어 있는 것이죠.
이런 배포본으로 세팅 작업을 시작한다면, 혹시 GPIO2, GPIO3, GPIO29에 연결 된 버튼(GND와 쇼트하는)이 있는 상태라면, 입력 버튼에 관한 드라이버 설정이 완전히 마무리 짓기 전엔 절대 그 버튼들을 막 눌러대선 안 됩니다.

​

간단히... 상황재현을 해 보겠습니다.

> 평범하게 GND와 쇼트하는 형태로 버튼들을 연결하여 결선을 끝낸 게임기가 있습니다.
> 
> 어느날 신버전의 커펌 배포본을 구하게 되어서 SD 카드에 룰루랄라 구웠습니다.
> 그리고 게임기에 꽂혀 있던 SD 카드는 일단 빼서 보관하고,
> 새로 구운 SD 카드를 게임기에 삽입하고 전원을 켰습니다.
> 혹시나 호환되도록 버튼 설정이 되어 있지 않을까 싶어서 일단 버튼을 몇개 눌러 봅니다.
> 뭐, 역시나 동작을 하지 않네요.
> 어쩔 수 없이 조이스틱 및 버튼에 관한 작업을 추가해야 하려나 봅니다.
>
> 네트웍 설정을 하고 콘솔로 접속한 다음, GPIO 입력을 하는 mk_arcade_joystick_rpi 드라이버를 설치하고,
> GPIO 설정까지 마쳤습니다.
> 그리고 리부팅을 해서 드라이버를 활성화 시켰습니다.
> 
> 이제 키 매핑을 할 차례입니다.
> 그런데, 몇몇 버튼은 눌러도 아무 반응이 없습니다.
> 어떤 버튼은 계속 눌린 상태로 인식합니다.
> 또 어떤 버튼은 한개만 눌렀는데 다른 버튼도 함께 동시에 눌린 것으로 인식하는 등... 한마디로 몇개 버튼이 완전히 이상 동작을 하고 있습니다.
> 
> 이상한 마음에 일단 전원을 껐습니다.
> 그리고 이전에 잘 동작하던 펌이 담긴 SD 카드를 다시 꽂습니다.
> 혹시나 싶어 이전 SD 카드를 지우지 않고 남겨 둔 것을 다행으로 생각하면서요.
> 그런데 이 SD 카드를 꽂고 부팅했음에도, 이전에 잘 입력되던 버튼들이 갑자기 앞서와 같이 똑같은 이상 동작을 보입니다.
> 
> 이쯤 되면 펌 문제가 아니라 기기 자체가 하드웨어적으로 문제가 생겼음을 알게 됩니다.
> 
> 도대체 무슨 잘못을 한 걸까요?


위의 상황은 게임기를 만들다 보면 쉽게 겪을 수 있는 상황입니다.
게임기 제작 커뮤니티 등에서도 이런 문제를 호소하는 사람도 많으며, 게임기 제작을 많이 하던 고인물들 사이에선 GPIO가 맛 간 라즈베리파이를 몇개씩 갖고 있는 사람들이 흔합니다.

원인은 바로 두번째 문단의, '혹시나 싶어서 버튼들 몇개를 눌러 본 것' 때문입니다.
새로 구한 펌에서는 몇개 GPIO가 OUTPUT 모드로 되어 있었던 것이고, 하필 이것과 연결 된 버튼을 누르는 순간 이 GPIO는 GND와 직결되며 과전류가 흘러 바로 사망해 버린 것입니다.

아주 주의해서 세팅을 한다면 모르겠지만, 무심결에 저런 실수는 충분히 할 수 있습니다.
때문에 저런 경우, 해당 GPIO에 최대 전류 이상이 흐르지 않도록 회로적으로 보완을 할 필요가 있습니다.
참고로, 라즈3B의 경우, GPIO에 허용 된 전류는 다음과 같습니다.

> #### 출력
>
> * 핀당 최대 8mA
> * 모든 핀을 다 합쳐서 총 전류가 최대 50mA
> ※ SMD타입의 칩 LED가 아닌, 일반적인 LED 한개만으로도 10mA 이상을 소모하기 때문에 저항 없이는 단 한개의 LED도 다이렉트로 GPIO에 물리면 안 됩니다.
> 
> #### 입력
> 
> * 1.8V의 임계 값. 즉, 1.8V는 1, 그 이하의 전압은 0으로 인식.
> * 최대 0.5mA (출력의 경우보다 훨씬 작은데, 원래 입력 쪽이 더 섬세합니다.)
※ 단지 전위치만 측정하면 되기 때문에 굳이 큰 전류가 필요하진 않습니다.
> * 3.3V 소스일 경우, 전류가 0.5mA를 초과 할 수 없도록 약 6.6Kohm 저항을 사용
(3.3V / 6600ohm = 0.5mA)
> * 내부 pull-up 저항은 50Kohm ~ 65Kohm이고, pull-down은 50Kohm~60Kohm.
(단, GPIO2과 GPIO3에는 정상적인 I2C 동작을 위해 그냥 INPUT 모드로 해도 기본적으로 1.8Kohm의 pull-up 저항이 물려 있습니다.)
> * GPIO2,3은 기본적으로 1.8Kohm으로 pull-up

여기서 주목해야 할 문단이... 중간에 6.6Kohm 저항을 사용하여 전류량을 제한해 준다는 부분이죠. 이런 보호 저항을 붙이면 혹여 실수로 GND와 쇼트가 났더라도 과전류로 GPIO가 죽는 일을 방지해 줍니다.

답이 나왔네요. 그냥 버튼과 GPIO 사이에 6.6K 저항 하나씩만 넣어 주면 되는 겁니다. 간단하죠?

이때 고려해 봐야 할 사항이, 내부 풀업 저항과 보호 저항이 동시에 적용하게 되면 입력 전압 레벨에 변화가 있을 거라는 사실입니다.
실제로 GPIO 모드를 내부 풀업저항 모드로 하고, 추가적으로 GPIO 핀에 보호 저항을 붙인다면 다음과 같은 형태가 될 것입니다.

![](https://velog.velcdn.com/images/amos42/post/5b0e5304-db3f-43e3-be54-b59d1ed18cfd/image.png)

버튼을 누르면 GND와 쇼트가 될테고, 그럼 이것을 풀어서 표시하면 최종적으로 다음과 같은 형태가 되는 것입니다.

![](https://velog.velcdn.com/images/amos42/post/968df691-7beb-42bb-8472-abb5ebd191d1/image.png)

즉, 저항비에 의해 전압 분주가 생기는 거죠. 이렇게 되면 버튼을 누른 상태에서도 GPIO에 걸리는 전압이 0V가 아닐 수도 있습니다.

실제로 계산을 한번 해 보죠.

풀업 저항은 최하치인 50K로 잡고, 보호저항은 6.6K로 잡습니다. 저항비 계산기 돌려 보면 출력전압이 나옵니다.

![](https://velog.velcdn.com/images/amos42/post/e063929e-251c-4707-a875-81c7dd174589/image.png)

원래는 0V가 나왔어야 했는데, 보호저항을 붙이는 바람에 실제로는 0.38V 정도 나오겠네요. 즉, 버튼을 안 눌렀을 땐 3.3V, 버튼을 눌렀을 땐 0.38V가 나온다는 것입니다. 그래도 임계값인 1.8V보다 훨씬 낮기 때문에 버튼 눌렀을 때 오인식은 안 할 듯 합니다.

(참고로, 풀업저항의 스펙상의 최대치인 65K로 잡으면 0.3V가 나옵니다.)

여기서 또 하나 고민해야 할 것이... 바로 GPIO2과 3입니다. 이 핀은 I2C용으로 쓰이며, 풀업 저항이 훨씬 낮습니다. 때문에 보호저항을 붙이면 문제가 될 수 있습니다.

![](https://velog.velcdn.com/images/amos42/post/a5660a4b-388b-4857-83ad-3dec04f7bed5/image.png)

실제 계산해 보니 2.6V에 육박하네요. 즉, 버튼을 안 누를 땐 3.3V, 버튼을 누를 땐 2.6V라는 말입니다. 임계치인 1.8V를 상회하기 때문에 버튼을 누른 것을 인식하지 못 한다는 것이죠. 아무래도 GPIO2와 3엔 이대로는 보호저항을 붙이면 안 되겠습니다. 이 핀은 버튼 입력을 연결하지 말든가, 만약 연결했다면 그 버튼만큼은 좀 주의해야죠 뭐... ^^;;;

(참고로, 현재 mk_arcade_joystick_rpi와 같은 드라이버는 이 핀을 HotKey로 사용하고 있습니다.)

자, 이제 본격적인 작업을 해 봅니다.
6.6Kohm 저항은 표준저항이 아니라서 2개 저항을 조합해야 합니다.
(참고로, 가장 근접한 표준 저항값은 6.2Kohm과 6.8Kohm입니다.)
귀찮으면 약간 더 높은 저항값을 써도 상관 없습니다만, 무작정 너무 높은 저항을 걸면 아예 버튼을 인식하지 못 하게 될 수도 있습니다.

![](https://velog.velcdn.com/images/amos42/post/2923e903-123f-4fe5-a25b-8cb19d9a41cb/image.png)

부품통을 뒤져 보니 유사한 값의 저항은 없고 대신 왜인지 5.6Kohm 저항이 엄청 쌓여 있었습니다.
5.6Kohm을 사용하면 최대 0.59mA 정도가 나와서 잠시 고민을 했지만, 지속적으로 이런 전류가 들어오기보다는 실수했을 때 잠깐 흐르는 전류라는 점을 감안하면 이 정도는 충분히 버티리라 생각해서 그냥 사용했습니다.
입력 키 쪽에서 오는 선의 중간에 저항을 하나씩 붙여 줍니다.
GND엔 붙일 필요 없습니다.
또한 GPIO2 혹은 3과 연결할 HotKey 버튼에 해당하는 핀도 저항을 안 붙여도 됩니다.

![](https://velog.velcdn.com/images/amos42/post/1de5f870-42c5-4044-a329-5d0ee225a94a/image.png)

저항선이 가늘기 때문에 좀 움직이면 끊어질까 봐 글루건으로 떡칠을 해서 단단히 고정시켰습니다.

실제로 사용한 모습은 다음과 같습니다.

![](https://velog.velcdn.com/images/amos42/post/5b9137ae-33ed-4d4c-a75b-899a640565e3/image.png)

이렇게 하면 혹시 실수로 OUTPUT 상태로 설정 된 GPIO에 버튼이 물린 상태라 할지라도, 버튼을 눌러도 해당 GPIO로 고전류가 흘러서 라즈가 망가지는 일은 없게 되겠죠.

GPIO는 아주 주의해서 사용해야 합니다.
'날 연결해 주세요' 라는 느낌으로 눈에 띄게 솟아 있는 핀들 때문에 착각하면 안 됩니다.
부디 부주의로 인해 라즈의 GPIO를 사망시키는 일이 더이상 생기지 않기를... ^^
