---
title : 라즈베리파이용 Arcade 입력 드라이버 am_joyin 소개
date : 2023-02-05 21:49:00 +09:00
categories : [TOP_CATEGORIE, SUB_CATEGORIE]
tags : [DIY프로젝트]
---

![](https://velog.velcdn.com/images/amos42/post/b54795c6-fe9d-4212-bcf0-495eb9c0c041/image.png)

라즈베리파이와 같은 SBC를 기반으로 게임기를 만들 때 제일 큰 관건은 입출력에 관한 문제입니다. 이 중에 출력 부분은 사실 그리 크게 고민할 필요가 없습니다. 거의 정형화 되어 있으니까요. 하지만 입력 쪽은 생각보다 선택의 폭이 넓습니다. 이는 과거 게임들이 꽤 다양한 입력 장치를 시도했었기 때문이기도 하고, 이것들이 표준적인 인터페이스를 갖고 있지 못 해서이기도 합니다.
여기에 더해 SBC는 GPIO와 별도의 입력 소자들을 조합해서 다양한 입력이 가능하기도 합니다.
하드웨어적으로는 이렇게 다양한데... 문제는... 드라이버입니다. 게임기를 위한 입력 드라이버는 거의 없다시피 하고, 겨우 지원되는 극소수 드라이버도 단순한 GPIO의 on/off만을 체크하여 버튼을 눌렀다 떼는 동작만을 감지하는 단순한 형태의 기능만을 지원하고 있습니다.
때문에 다른 종류의 장치를 지원하려면 사실상 USB를 이용할 수밖에 없고, 중간에 아두이노나 라즈베리파이 피코와 같은 제어를 담당하는 장치를 만들어 거기에 펌웨어를 올려서 처리를 하도록 만들어야 합니다.
이 경우, 여러 다른 종류의 입력 장치를 사용하기 위해서는 그에 맞는 펌웨어를 작성해야 한다는 부담이 생기는 것은 물론이고, 상황에 따라 입력 장치의 조합을 만든다거나 하는 것도 쉽지 않게 됩니다.

이런 문제를 해결하기 위해서는, 다양한 상황에서 다양한 입력 장치에 대응하기 위한 드라이버가 필요합니다. 물론 현재까지 그런 드라이버는 눈 씻고 찾아도 없었습니다.
그래서... 직접 만들기로 했습니다. ^^

근 한달 동안 이렇게 저렇게 삽질하며 만든 새 라즈베리파이 입력 드라이버를 공개합니다.
이름하여 am_joyin 입니다. (일부러 이름 짧게 지었어요. 타이프하기 귀찮아서... ㅎㅎㅎ)
아직까진 알파버전 수준이지만... 그래도 나름 안정적으로 잘 동작하는 것 같아서 마냥 붙잡고 있기보다는 일단 그냥 공개합니다.
일단 여러 사람들이 써봐야 미처 발견 못 한 문제들이 뭔지 알 수 있고, 그래야 제대로 완성을 시킬 수 있을 것 같아서요. ^^

드라이버의 위치는 다음 링크에서 찾을 수 있습니다.

> [https://github.com/amos42/am_joyin](https://github.com/amos42/am_joyin)

보통 GPIO를 이용한 입력 드라이버로 많이 쓰는 것이 mk_arcade_joystick_rpi일텐데, 이게 나름 간편하고 안정적으로 동작은 하지만, 문제는 너무 오래 전에 만들어졌고, 그 이후 거의 업데이트가 일어나지 않는다는 것입니다.
타 기종으로 포팅되는 것은 고사하고, 같은 라즈베리파이인 라즈4에서조차 동작을 안 하기에, 결국 오피셜이 아닌 유저가 포팅을 하는 지경이 이르렀습니다.
또 하나의 문제는, 기능이 너무 빈약하다는 것입니다. 사실상 그냥 딱 고정 된 키배열을 GPIO로 매핑시켜 주는 기능밖에 없습니다. (I2C 방식의 IO칩도 하나 지원해 줍니다.)
결국 뭔가 조금이라도 커스터마이징을 하고 싶다면 소스를 직접 수정해 쓸 수밖에 없습니다.
여기에서 또다른 문제가 나오는데... 바로 소스가 너무 난잡해서 사용자가 직접 수정해 쓰기도 무척 곤란하다는 것입니다.

이런저런 이유 때문에 결국 아예 새로 드라이버를 만들기로 결심했습니다.
여지껏 몇대인가 게임기를 만들면서 필요로 했던 것들을 다 녹여 내는 것은 물론이고,
최대한 소스 수정 없이 설정만으로 다양한 커스터마이징이 가능하도록 하면 좋겠다 싶어서,
설정 부분에 최대한 신경을 쓰려 노력했습니다.
(사실 기본 구조와 기능은 금방 완성했는데, 바로 이 설정 때문에 한달을 고민 속에 보내야 했습니다. ^^;;)

자, 여기까지가 사설이고... (언제나 사설이 깁니다. ㅎ)
그럼 이 am_joyin의 장점이 무어냐?

### 특징과 장점

1. 사용이 간편하다.
mk_arcade_joystick_rpi 보다 조금 더 사용이 간편합니다. 사실상 거의 default에 해당하는 상태로 쓰려고 할지라도 일단 반드시 설정은 필요합니다. default를 쓰겠다고 하는 설정 말이죠.
그에 반해서 am_joyin은 드라이버 설치하고 등록만 하면 아무 설정 없이도 일단 default 상태로 들어갑니다. default는 gpio 1p 장치 한개를 사용하도록 했고, 이는 mk_arcade_joystick_rpi와 동일한 기능을 의미합니다.

2. 파라미터를 통해 디테일한 설정이 가능하다.
실제로 게임기를 만들다 보면 버튼의 갯수가 늘거나 줄 수도 있고, 버튼 하나가 여러개의 입력으로 동시에 작용하거나, 반대로 2개의 버튼이 1개의 동일한 입력으로 동작하게 한다거나 하는 식으로 동작하게 했으면 좋겠다고 생각할 때가 있습니다. 또한 서로 다른 입력 장치를 통해 들어온 입력을 한개의 입력 장치인 것처럼 동작하게 하고 싶을 때도 있습니다. 예를 들어, 스틱은 아날로그 스틱으로부터 아날로그 값을 SPI나 I2C로 받고, 버튼은 GPIO로 받는다든가 하는 식이죠. 심지어 한개의 입력 장치로부터 1p, 2p 입력을 동시에 받아서 그걸로 조이스틱 2개로 인식하게 한다거나 하고 싶을 때도 있습니다.
이런 복합적인 상황을 수용하려면 역시 이에 딱 맞는 드라이버를 개발해야 하는데, 이걸 입력 장치 설계할 때마다 하는 것은 힘들기도 하거니와, 실제로 대다수가 드라이버 개발 능력이 없다는 점을 감안하면 현실적이지 않습니다.
그래서 이런 상황에서조차 드라이버 소스 수정 없이, 오직 설정만으로 수용할 수 있는 방법을 고안해 냈습니다.

3. 지원 장치가 다양(?)하다.
mk_arcade_joystick_rpi는 GPIO 다이렉트 입력과 mcp27013이라는 I2C 방식의 IO 칩만을 지원합니다.
하지만 am_joyic은 이 2가지는 물론 지원하고, 추가로 mux와 74hc165를 지원하며, 아날로그 조이스틱 입력을 위해 I2C, SPI 방식의 ADC칩들도 지원합니다. 알카노이드 스피너를 지원하기 위해 로터리 엔코더도 지원하구요.
또한 소스 구조를 좀 더 명확히 하고 확장 가능하게 해서, 혹 다른 사람들이 자신만의 장치를 추가하여 커스터마이징 하는 것을 용이하도록 했습니다.

4. 예외 처리를 좀 더 강화했다.
mk_arcade_joystick_rpi도 사실 그렇게까지 안정적인 드라이버가 아닙니다. 한정 된 상황에서 한정 된 용도로만 써서 그렇지, 드라이버 설치 및 사용 시에 조금 실수를 하게 되거나 다른 드라이버들과 충돌 상황이 발생하면 딱히 예외 처리다 싶은 것을 해 주지도 않습니다. 커널 패닉까진 몰라도, 일단 충돌해서 오동작을 하거나 아무 이유 없이 오동작을 하게 됩니다.
am_joyin은 상대적으로 좀 더 예외처리를 위한 방어 코드를 많이 넣었습니다. 그리고 혹 발견되는 문제 상황을 레포트 받으면 아무 소식이 없는 mk_arcade_joystick_rpi와는 달리, 적극적으로 디버깅에 임할 것입니다. ^^

5. 소스가 좀 더 체계적이다.
사실 커널 모듈은 일반 라이브러리처럼 구조적인 소스 관리가 힘듭니다. object 파일 달랑 하나로 이루어져 있으니까요. 그러다 보니 드라이버가 소스 파일 단 한개로 이루어져 있는 경우가 많습니다. mk_arcade_joystick_rpi도 mk_arcade_joystick_rpi.c 파일 딱 하나로 이루어져 있습니다.
am_joyin은 그래도 어느 정도 소스를 용도별로 분리한 다음, 메인 소스에 include 시키는 형태로 작성했습니다. 어차피 최종적으로는 소스 한개로 모아져 빌드되지만, 여하튼 눈으로 보기엔 소스가 분리되어 있고, 기능별로 개별적인 소스에 담겨 있다는 의미입니다.
이는 향후 새로운 장치를 추가하거나 기능을 보강할 때 확연히 장점이 되며, 이 소스를 가져다가 자신만의 커스터마이징을 하고자 하는 이들에게도 유리한 점이 될 수 있습니다.

6. 지원 플랫폼이 더 많아질(?) 것이다.
현재 mk_arcade_joystick_rpi는 라즈3까지만 공식적으로 지원합니다. 비공식적으로 유저가 라즈4용도 포팅해 놨지만, 어디까지 오피셜은 3까지입니다. 또한 소스 구조 상, 다른 플랫폼으로 포팅 될 가능성은 거의 희박해 보입니다.
am_joyin은 일단 라즈2, 라즈3와 라즈4를 모두 지원하고, 아직까진 이 정도이지만 향후 오드로이드 N2+와 리니지OS 등도 지원 할 계획을 가지고 있습니다. (이 부분은 전적으로 제 귀차니즘에 달려 있다고 봐야 합니다만... ㅎ)

7. 이름이 짧다?
농담입니다. ㅎㅎㅎ
mk_arcade_joystick_rpi 계속 이리저리 쓰다 보니 이름이 길어서 타이프가 귀찮을 때가 많더군요. 오타도 많이 나고... ^^;;;

### 드라이버 설치 및 사용

그럼 이제 본격적으로 드라이버를 설치해서 사용하는 방법을 알려드리겠습니다.

먼저, 대상은 retropie 계열을 사용한다고 가정하겠습니다.
왜냐하면 이들 배포 이미지들은 개발을 위한 환경이 기본적으로 갖춰져 있기 때문입니다.
다른 이미지를 사용하고 있다면 상황에 따라 개발 환경을 따로 갖춰야 할 수도 있습니다.
또 하나, 드라이버 설치에 앞서 혹 이미 mk_arcade_joystick_rpi를 사용하고 있다면, 먼저 이를 제거해 줘야 합니다.
제거 방법은 몇가지가 있는데, 일단 커맨드 라인으로 설명하자면 다음과 같습니다.

> 1. 라즈베리파이에 ssh로 접속
> 2. sudo ~/RetroPie-Setup/retropie_setup.sh
> 3. 메뉴 중 Manage packages - driver - mkarcadejoystick - Remove 선택
> 4. 라즈베리파이 재시작

가급적이면 mk_arcade_joystick_rpi 외에도 입력 드라이버로 사용하고 있는 것들 중, GPIO 입력 드라이버들이 더 있다면 다 제거해 주는 것이 좋습니다.

기존 드라이버들이 제거되었다면, 이제 am_joyin 설치할 차례입니다.

드라이버 설치는 라즈베리파이에 ssh로 접속 한 다음, 아래의 커맨드들을 차례로 실행해 주면 됩니다.

```bash
$ git clone https://github.com/amos42/am_joyin.git
$ cd am_joyin
$ ./utils/makepackage.sh 0.1.0
$ sudo dpkg -i build/am_joyin-0.1.0.deb
```

드라이버 설치는 이걸로 끝입니다.
하지만 드라이버가 설치만 되었을 뿐, 실제 로딩이 이루어지진 않습니다.
로딩을 위해선 modprobe 명령을 써야 하는데, 해당 명령을 시작 스크립트에 넣어도 되지만, 보통은 모듈 관리 스크립트에 넣습니다.

```bash
$ sudo nano /etc/modules-load.d/modules.conf
```

파일을 에디터로 연 다음. 끝에 다음의 문장을 추가해 줍니다.

```
.
.
.
am_joyin
```

이 상태로 sudo reboot 하시면 새로운 키보드 드라이버가 동작합니다.
아무 설정 없이 로딩했으니 기본적으로 mk_arcade_joystick_rpi와 동일한 동작을 합니다.

드라이버 삭제는 위의 과정의 역순으로 하면 됩니다.
(추가 해 준 것들 삭제하면 됩니다.)

드라이버 패키지를 삭제하는 명령은 다음과 같습니다.

```bash
$ sudo dpkg -r am-joyin-dkms
```

### am_joyin 설정

am_joyin의 가장 큰 장점은 설정을 통해 여러 장치를 연결할 수 있다는 점입니다.

설정 파일의 위치는 /etc/modprobe.d/am_joyin.conf 입니다.

다음의 명령어로 에디터로 열어서 편집하면 됩니다.

```bash
$ sudo nano /etc/modprobe.d/am_joyin.conf
```

입력 내용은 다음과 같은 형식으로 하면 됩니다.

```
options am_joyin buttonset1="........" endpoints="......." device1="......."
```

각 파라미터의 값들은 모두 " " 로 감싸 줘야 하며, 여러 라인을 사용하고 싶다면 끝에 \ 문자를 넣어주면 됩니다.

기본적으로 설정을 위해선 3가지를 설정해 줘야 합니다.
(일부는 귀찮다면 생략할 수 있습니다. 그 경우 default 값으로 지정됩니다.)

첫째는 버튼셋입니다.

버튼들에 해당하는 코드의 배열과 각 버튼의 최소, 최대값을 지정합니다.
사용자가 따로 지정하지 않아도 기본적으로 1개의 버튼셋이 포함되어 있으며, 이는 기본적으로 mk_arcade_joystick_rpi와 앞의 13개(핫키 포함)까지는 동일한 배열을 갖고 있습니다.

버튼셋 지정을 위해선 buttonset1, buttonset2 을 각각 사용 가능하며, 차례로 인덱스 1과 2를 갖습니다. 0번은 default로 기본 포함 된 버튼셋입니다.

다음과 같이, {키코드,최소값,최대값}을 묶어서 원하는 갯수만큼 나열하면 됩니다.

```
buttonset1_cfg="{0x01,-1,1},{0x00,-1,1},{0x13B,0,1},{0x13A,0,1},{0x130,0,1},{0x103,0,1},{0x102,0,1},{0x103,0,1},{0x102,0,1},{0x103,0,1}"
```

많은 경우, 게임기에선 딱히 변경할 필요가 없을 거라 생각해서 내장 된 0번 셋을 쓰게 될테지만, 필요에 따라 2개까지만 추가로 입력 가능하게 한 것입니다.

두번째로 엔드포인트입니다.

엔드포인트는 실제로 입력 장치로 보여주게 하는 단위입니다.
실제로 OS 상에서 /dev/input/js0, /dev/input/js1, ... 등과 같은 파일 한개에 대응됩니다.

이 설정은 그다지 중요한 내용은 없기 때문에 총 몇개의 엔드포인트를 쓸 것인가 정도랑 어떤 버튼셋을 사용할 것인가 가장 중요한 정보라 할 수 있겠네요.
생략할 경우엔 그냥 기본 이름과 기본 버튼셋을 갖는 1개의 엔드포인트가 만들어집니다.
그러니 2p 이상을 쓸 거라면 꼭 지정해 줘야 합니다.

형식은 다음과 같습니다.
복수개 지정시, 각 엔드포인트 설정은 ; 문자로 구분합니다.

```
endpoints="엔드포인트1이름,버튼셋,사용버튼 갯수;엔드포인트2이름,버튼셋,사용버튼 갯수;..."
```

실제로 엔드포인트 2개를 생성하도록 지정할 땐 다음과 같은 형식으로 적습니다.
버튼셋과 사용 버튼 갯수 모두 default로 지정했습니다.

```
endpoints="AmosJoystick_1,default,default;AmosJoystick_2,default,default"
```

각각의 값은 생략시 모두 default를 의미합니다. 이름을 생략할 경우엔 "AmosJoystick_#"과 같은 형식으로 자동 지정됩니다. 즉, 위의 경우를 축약하자면 다음과 같습니다

```
endpoints=";"
```

; 문자로 구분 된 2개를 지정했는데, 실제 값은 모두 생략되어 있으니 기본 값으로만 2개의 엔드포인트가 생성됩니다.

세번째로 가장 중요한 장치 설정입니다.

실제로 어떤 장치가 연결되는가를 지정합니다.
한개의 장치가 복수개의 엔드포인트를 대상으로 할 수도 있고, 복수개의 장치가 한개의 엔드포인트만을 사용할 수도 있습니다.
총 4개까지 지정이 가능한데, 일반적인 DIY 게임기 만들 땐 그 이상 필요할 것 같지 않아서 제한을 뒀습니다.
각 장치의 파라미터명은 device1 ~ device4 중 하나를 선택해 지정하면 됩니다.

기본 형식은 다음과 같습니다.

```
device1="장치명;장치 파라미터;엔드포인트1인덱스,엔드포인트1키시작인덱스,엔드포인트1키갯수,엔드포인트1파라미터;엔드포인트2인덱스,엔드포인트1키시작인덱스,엔드포인트2키갯수,엔드포인트2파라미터; ...."
```

장치명으로 사용 가능한 것은 현재 4개입니다.


| 장치명 |  |
|---|---|
| gpio |  |
| mcp23017 |  |
| 74hc165 |  |
| mux |  |

각각은 기본적으로는 같은 파라미터 형식을 갖는데, 실제 장치 파라미터와 엔드포인트 파라미터는 다른 내용으로 해석됩니다.

#### gpi:
- 장치 파라미터 : 없음
- 엔드포인트별 파라미터 : gpio매핑 정보 (default1, default2, custom 중 하나를 지정, custom의 경우엔 이후에 gpio 주소 정보)

#### mcp23017:
- 장치 파라미터 : i2c 주소
- 엔드포인트별 파라미터 : 버튼셋과 입력값 쌍 배열 (default, custom 중 하나를 지정)

#### 74hc165:
- 장치 파라미터 : ld, ck, dt 번호, bit_order gpio
- 엔드포인트별 파라미터 : 버튼셋과 입력값 쌍 배열 (default, custom 중 하나를 지정)

#### mux:
- 장치 파라미터 : 읽기핀 gpio, 주소핀 gpio의 배열
- 엔드포인트별 파라미터 : 버튼셋과 입력값 쌍 배열 (default, custom 중 하나를 지정)

대충 이 정도입니다.

예를 들어, gpio 장치 2p용으로 지정하고자 한다면 다음과 같습니다.

```
endpoints="joy1,default,12;joy2,default,12" device1="gpio;;0,default1,0,12;1,default2,0,12"
```

만약 GPIO의 주소를 커스터마이징 하고자 한다면 다음과 같이 작성합니다.

```
device1="gpio;;0,custom,1,{4,0,-1},{17,0,1},{27,1,-1},{22,1,1},{10,2,1},{9,3,1},{25,4,1},{24,5,1},{15,6,1},{18,7,1},{14,8,1},{23,9,1},{2,10,1}
```

custom의 형식은 첫번째 인덱스 모드면 0, 키코드 모드면 1 이고, 이후로는 { }로 묶어서 {gpio 번호, 버튼인덱스, 값} 와 같은 형식으로 원하는만큼 지정하면 됩니다.

상하좌우 버튼의 경우엔 X, Y로 각각 따로 할당되어 있기 때문에 값은 키 인덱스에서 값을 -1이냐 1을 주냐로 지정하면 됩니다.
(만약 버튼셋의 인덱스가 아닌, 아예 다른 키코드를 쓰고 싶다면 키코드를 직접 입력할 수도 있지만, 여기에선 생략하고, 메뉴얼을 참고해 주세요. ^^)

74hc165를 이용해 1p 지정은 다음과 같습니다.
(ld,ck,dt를 각각 16,20,21번에 연결했을 경우)

```
device1="74hc165;16,20,21,,1;0,0,default"
```

74hc165로 2p 지정을 하면 다음과 같습니다.

```
endpoints=";" device1="74hc165;16,20,21,,1;0,default;1,default"
```

조금 색다른 구성을 해서, 버튼 중 앞의 6개는 gpio로, 나머지 6개는 74hc165에서 받아서 최종적으로 한개의 /dev/input/js0 으로 보내는 형태를 원한다면 다음과 같이 작성합니다.

```
device1="gpio;;0,default,0,6" device2="74hc165;16,20,21;0,default,6,6"
```

즉, 장치는 달라도 같은 엔드포인트 0번 인덱스를 사용하면 되는 것이죠. 간단하죠? ^^

현재 알파 버전이고, 계속 제작 및 수정이 이어지고 있는 상태라 인터페이스도 변경 될 가능성이 있습니다.
때문에 실제 스펙과 사용법은 github의 메뉴얼을 참조하는 것이 더 낫습니다.

아무쪼록 널리 사용되어서 DIY 게임기 제작하는 사람들에게 도움이 되길 바랍니다.
